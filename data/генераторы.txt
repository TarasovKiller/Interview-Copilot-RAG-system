Генераторы и итераторы в Python
1️⃣ Как кратко ответить
Генератор в Python — это функция, которая возвращает итератор и использует ключевое слово yield вместо return. Генераторы позволяют создавать последовательности значений "лениво" — по одному за раз, что экономит память при работе с большими объёмами данных. Итератор — это объект, который реализует методы __iter__() и __next__() и позволяет перебирать элементы коллекции.

2️⃣ Подробное объяснение темы
Что такое итератор?
Итератор — это объект, который позволяет последовательно обходить элементы коллекции. Итератор должен реализовывать два метода:

__iter__() — возвращает сам объект итератора
__next__() — возвращает следующий элемент или вызывает StopIteration

Пример создания итератора:

class Counter:
    def __init__(self, max_value):
        self.max_value = max_value
        self.current = 0
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.current < self.max_value:
            self.current += 1
            return self.current
        raise StopIteration
​
counter = Counter(5)
for num in counter:
    print(num)  # Вывод: 1, 2, 3, 4, 5

Что такое генератор?
Генератор — это более простой способ создания итератора. Вместо создания класса с методами __iter__ и __next__, вы просто используете функцию с ключевым словом yield.

Простой пример генератора:

def count_up_to(max_value):
    current = 1
    while current <= max_value:
        yield current
        current += 1
​
for num in count_up_to(5):
    print(num)  # Вывод: 1, 2, 3, 4, 5

Как работает yield?
Когда функция содержит yield, она становится генератором. При вызове такой функции:

Код не выполняется сразу
Возвращается объект-генератор
При каждом вызове next() выполнение продолжается до следующего yield
Состояние функции сохраняется между вызовами

def simple_generator():
    print("Начало")
    yield 1
    print("После первого yield")
    yield 2
    print("После второго yield")
    yield 3
    print("Конец")
​
gen = simple_generator()
print(next(gen))  # Вывод: Начало, 1
print(next(gen))  # Вывод: После первого yield, 2
print(next(gen))  # Вывод: После второго yield, 3

Генераторные выражения:
Подобно списковым включениям, существуют генераторные выражения — более компактный способ создания генераторов.

# Списковое включение (создаёт список в памяти)
squares_list = [x**2 for x in range(1000000)]
​
# Генераторное выражение (создаёт генератор)
squares_gen = (x**2 for x in range(1000000))
​
# Генератор занимает значительно меньше памяти!
import sys
print(sys.getsizeof(squares_list))  # ~8 МБ
print(sys.getsizeof(squares_gen))   # ~120 байт

Преимущества генераторов:
Экономия памяти: Значения создаются по требованию, а не все сразу
Ленивые вычисления: Вычисления выполняются только когда нужно
Работа с бесконечными последовательностями: Можно создавать бесконечные потоки данных
Чистый код: Генераторы часто проще и читабельнее классов-итераторов

Пример бесконечного генератора:

def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b
​
fib = fibonacci()
for _ in range(10):
    print(next(fib), end=" ")
# Вывод: 0 1 1 2 3 5 8 13 21 34

Методы генераторов:
Генераторы имеют дополнительные методы:

send() — отправляет значение в генератор
throw() — вызывает исключение внутри генератора
close() — завершает генератор

def echo():
    while True:
        received = yield
        print(f"Получено: {received}")
​
gen = echo()
next(gen)  # Инициализация
gen.send("Привет")  # Вывод: Получено: Привет
gen.send("Мир")     # Вывод: Получено: Мир

Где применяются генераторы?
Генераторы широко используются:

Обработка больших файлов: Чтение файла построчно без загрузки в память
Потоковая обработка данных: Обработка данных по мере поступления
Пайплайны данных: Цепочки обработки с промежуточными генераторами
Веб-скрапинг: Постраничная загрузка данных
Работа с API: Пагинация результатов

Пример чтения большого файла:

def read_large_file(file_path):
    with open(file_path, 'r') as file:
        for line in file:
            yield line.strip()
​
for line in read_large_file('huge_file.txt'):
    process(line)  # Обрабатываем по одной строке

