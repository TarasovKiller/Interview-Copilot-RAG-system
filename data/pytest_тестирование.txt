Pytest и тестирование
1️⃣ Как кратко ответить
Pytest — это популярный фреймворк для тестирования Python-кода, который отличается простым синтаксисом и мощными возможностями. Pytest поддерживает юнит-тесты, интеграционные тесты, фикстуры для подготовки тестовых данных, параметризацию и плагины. Тестирование помогает убедиться, что код работает правильно, предотвращает регрессии при изменениях и служит документацией к коду.

2️⃣ Подробное объяснение темы
Зачем нужно тестирование?
Тестирование обеспечивает:

Качество кода: Проверка корректности работы
Уверенность в изменениях: Рефакторинг без страха
Документация: Тесты показывают, как использовать код
Раннее обнаружение багов: Дешевле исправить на этапе разработки
CI/CD: Автоматическая проверка перед деплоем

Установка и первый тест:

# pip install pytest pytest-cov pytest-asyncio
# test_example.py
​
def add(a, b):
    return a + b
​
def test_add():
    assert add(2, 3) == 5
    assert add(-1, 1) == 0
    assert add(0, 0) == 0
​
# Запуск: pytest test_example.py -v

Организация тестов:

project/
├── src/
│   └── myapp/
│       ├── __init__.py
│       ├── services.py
│       └── models.py
├── tests/
│   ├── __init__.py
│   ├── conftest.py          # Общие фикстуры
│   ├── unit/
│   │   ├── test_services.py
│   │   └── test_models.py
│   └── integration/
│       └── test_api.py
└── pytest.ini

Фикстуры (Fixtures):

import pytest
from myapp.database import Database
from myapp.models import User
​
@pytest.fixture
def sample_user():
    """Создаёт тестового пользователя."""
    return User(id=1, name="Test User", email="test@example.com")
​
@pytest.fixture
def db_session():
    """Создаёт сессию БД для теста."""
    db = Database(":memory:")
    db.create_tables()
    yield db
    db.close()
​
@pytest.fixture(scope="module")
def api_client():
    """Клиент API (создаётся один раз на модуль)."""
    from myapp import create_app
    app = create_app(testing=True)
    with app.test_client() as client:
        yield client
​
def test_create_user(db_session, sample_user):
    """Тест с использованием фикстур."""
    db_session.add(sample_user)
    saved_user = db_session.get_user(1)
    assert saved_user.name == "Test User"

Параметризация тестов:

import pytest
​
@pytest.mark.parametrize("input,expected", [
    ("hello", "HELLO"),
    ("world", "WORLD"),
    ("PyThOn", "PYTHON"),
    ("", ""),
])
def test_uppercase(input, expected):
    assert input.upper() == expected
​
@pytest.mark.parametrize("a,b,expected", [
    (2, 3, 5),
    (0, 0, 0),
    (-1, 1, 0),
    (100, 200, 300),
])
def test_add_parametrized(a, b, expected):
    assert add(a, b) == expected

Тестирование исключений:

import pytest
​
def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b
​
def test_divide_by_zero():
    with pytest.raises(ValueError) as exc_info:
        divide(10, 0)
    
    assert "Cannot divide by zero" in str(exc_info.value)
​
def test_divide_normal():
    assert divide(10, 2) == 5

Моки и патчи:

from unittest.mock import Mock, patch, MagicMock
import pytest
​
# Мок объекта
def test_with_mock():
    mock_db = Mock()
    mock_db.get_user.return_value = {"id": 1, "name": "Test"}
    
    result = mock_db.get_user(1)
    
    assert result["name"] == "Test"
    mock_db.get_user.assert_called_once_with(1)
​
# Патч внешнего сервиса
@patch('myapp.services.requests.get')
def test_fetch_data(mock_get):
    mock_get.return_value.json.return_value = {"data": "test"}
    mock_get.return_value.status_code = 200
    
    from myapp.services import fetch_data
    result = fetch_data("http://api.example.com")
    
    assert result == {"data": "test"}
​
# Патч как контекстный менеджер
def test_send_email():
    with patch('myapp.services.send_email') as mock_send:
        mock_send.return_value = True
        
        result = notify_user(user_id=1)
        
        assert result is True
        mock_send.assert_called_once()

Асинхронные тесты:

import pytest
import asyncio
​
@pytest.mark.asyncio
async def test_async_function():
    result = await async_fetch_data()
    assert result is not None
​
@pytest.fixture
async def async_db():
    db = await AsyncDatabase.connect()
    yield db
    await db.disconnect()
​
@pytest.mark.asyncio
async def test_async_db_query(async_db):
    users = await async_db.get_all_users()
    assert len(users) >= 0

Тестирование FastAPI:

from fastapi.testclient import TestClient
from httpx import AsyncClient
import pytest
from myapp.main import app
​
client = TestClient(app)
​
def test_read_root():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Hello World"}
​
def test_create_user():
    response = client.post(
        "/users",
        json={"name": "John", "email": "john@example.com"}
    )
    assert response.status_code == 201
    assert response.json()["name"] == "John"
​
# Асинхронное тестирование
@pytest.mark.asyncio
async def test_async_endpoint():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.get("/async-endpoint")
    assert response.status_code == 200

Маркеры и пропуск тестов:

import pytest
import sys
​
@pytest.mark.slow
def test_slow_operation():
    """Медленный тест, запускается отдельно."""
    pass
​
@pytest.mark.skip(reason="Не реализовано")
def test_future_feature():
    pass
​
@pytest.mark.skipif(sys.platform == "win32", reason="Только для Linux")
def test_linux_specific():
    pass
​
@pytest.mark.xfail(reason="Известный баг")
def test_known_bug():
    assert False  # Ожидаемо провалится

Конфигурация pytest.ini:

[pytest]
testpaths = tests
python_files = test_*.py
python_functions = test_*
addopts = -v --tb=short --strict-markers
markers =
    slow: marks tests as slow
    integration: marks tests as integration tests
filterwarnings =
    ignore::DeprecationWarning

Запуск тестов:

# Все тесты
pytest
​
# С покрытием кода
pytest --cov=myapp --cov-report=html
​
# Конкретный файл или тест
pytest tests/test_api.py
pytest tests/test_api.py::test_create_user
​
# По маркерам
pytest -m "not slow"
pytest -m integration

Где применяется pytest?

Юнит-тесты: Тестирование отдельных функций
Интеграционные тесты: Тестирование взаимодействия компонентов
API тесты: Проверка эндпоинтов
E2E тесты: Сквозное тестирование приложения
CI/CD: Автоматизация в пайплайнах

