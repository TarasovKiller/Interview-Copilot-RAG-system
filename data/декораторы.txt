Декораторы в Python
1️⃣ Как кратко ответить
Декоратор в Python — это функция, которая принимает другую функцию в качестве аргумента и возвращает новую функцию, расширяя или изменяя поведение исходной функции без изменения её кода. Декораторы позволяют добавлять функциональность к существующим функциям или методам, используя синтаксис @decorator_name.

2️⃣ Подробное объяснение темы
Что такое декоратор?
Декоратор — это мощный инструмент в Python, который позволяет модифицировать поведение функций или классов. По сути, декоратор — это функция высшего порядка, которая принимает функцию и возвращает новую функцию с добавленной функциональностью.

Зачем нужны декораторы?
Декораторы помогают:

Избежать дублирования кода: Общую логику (логирование, проверка прав доступа, кэширование) можно вынести в декоратор.
Соблюдать принцип DRY: Не повторять один и тот же код в разных функциях.
Разделить ответственность: Основная функция занимается своей логикой, а дополнительная логика выносится в декоратор.

Как работают декораторы?
В Python функции являются объектами первого класса, что означает, что их можно передавать как аргументы и возвращать из других функций.

Простой пример декоратора:

def my_decorator(func):
    def wrapper():
        print("До вызова функции")
        func()
        print("После вызова функции")
    return wrapper
​
@my_decorator
def say_hello():
    print("Привет!")
​
say_hello()
# Вывод:
# До вызова функции
# Привет!
# После вызова функции

Декоратор с аргументами:
Часто нужно, чтобы декорируемая функция принимала аргументы. Для этого используются *args и **kwargs.

def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Вызов функции {func.__name__}")
        result = func(*args, **kwargs)
        print(f"Результат: {result}")
        return result
    return wrapper
​
@my_decorator
def add(a, b):
    return a + b
​
add(3, 5)
# Вывод:
# Вызов функции add
# Результат: 8

Декоратор с параметрами:
Иногда нужно передать параметры самому декоратору. Для этого используется дополнительный уровень вложенности.

def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator
​
@repeat(times=3)
def greet(name):
    print(f"Привет, {name}!")
​
greet("Анна")
# Вывод:
# Привет, Анна!
# Привет, Анна!
# Привет, Анна!

Сохранение метаданных функции:
При декорировании функции теряются её метаданные (имя, документация). Чтобы этого избежать, используется functools.wraps.

from functools import wraps
​
def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper
​
@my_decorator
def example():
    """Это документация функции."""
    pass
​
print(example.__name__)  # Вывод: example
print(example.__doc__)   # Вывод: Это документация функции.

Где применяются декораторы?
Декораторы широко используются в Python:

Веб-фреймворки: Flask и Django используют декораторы для маршрутизации (@app.route, @login_required)
Логирование: Автоматическая запись вызовов функций
Кэширование: @lru_cache для мемоизации результатов
Валидация: Проверка входных данных перед выполнением функции
Измерение времени: Профилирование производительности функций

Встроенные декораторы:
Python предоставляет несколько встроенных декораторов:

@staticmethod — создаёт статический метод класса
@classmethod — создаёт метод класса
@property — создаёт свойство класса
@functools.lru_cache — кэширует результаты функции

