Инкапсуляция в Python
1️⃣ Как кратко ответить
Инкапсуляция — это один из основных принципов объектно-ориентированного программирования, который заключается в сокрытии внутренней реализации объекта и предоставлении доступа к данным только через определённые методы. В Python инкапсуляция реализуется с помощью соглашений об именовании: одинарное подчёркивание (_attr) указывает на защищённый атрибут, двойное подчёркивание (__attr) — на приватный.

2️⃣ Подробное объяснение темы
Что такое инкапсуляция?
Инкапсуляция — это механизм, который объединяет данные и методы, работающие с этими данными, в единый объект (класс) и скрывает детали реализации от внешнего мира. Это позволяет контролировать доступ к данным и защищать их от некорректного использования.

Зачем нужна инкапсуляция?
Инкапсуляция помогает:

Защитить данные: Предотвращает случайное или намеренное изменение важных данных извне.
Упростить интерфейс: Пользователь класса работает только с публичными методами, не зная о внутренней реализации.
Облегчить поддержку: Можно изменять внутреннюю реализацию без влияния на код, использующий класс.
Повысить надёжность: Валидация данных происходит в одном месте.

Уровни доступа в Python:
В Python нет строгих модификаторов доступа как в Java или C++, но существуют соглашения:

1. Публичные атрибуты (без подчёркивания):
Доступны везде, предназначены для использования извне.

class User:
    def __init__(self, name):
        self.name = name  # публичный атрибут
​
user = User("Иван")
print(user.name)  # Вывод: Иван

2. Защищённые атрибуты (одинарное подчёркивание _):
По соглашению, не должны использоваться извне класса, но технически доступны.

class User:
    def __init__(self, name, age):
        self.name = name
        self._age = age  # защищённый атрибут
​
user = User("Иван", 25)
print(user._age)  # Работает, но не рекомендуется

3. Приватные атрибуты (двойное подчёркивание __):
Python применяет механизм "name mangling" — имя атрибута изменяется на _ClassName__attr.

class User:
    def __init__(self, name, password):
        self.name = name
        self.__password = password  # приватный атрибут
    
    def check_password(self, pwd):
        return self.__password == pwd
​
user = User("Иван", "secret123")
# print(user.__password)  # AttributeError!
print(user._User__password)  # Работает, но это обход инкапсуляции
print(user.check_password("secret123"))  # Вывод: True

Геттеры и сеттеры:
Для контролируемого доступа к атрибутам используются методы-геттеры и сеттеры.

class BankAccount:
    def __init__(self, balance):
        self.__balance = balance
    
    def get_balance(self):
        return self.__balance
    
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
        else:
            raise ValueError("Сумма должна быть положительной")
    
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
        else:
            raise ValueError("Недостаточно средств или некорректная сумма")
​
account = BankAccount(1000)
account.deposit(500)
print(account.get_balance())  # Вывод: 1500

Использование @property:
Декоратор @property позволяет создавать свойства, которые выглядят как атрибуты, но на самом деле являются методами.

class Circle:
    def __init__(self, radius):
        self._radius = radius
    
    @property
    def radius(self):
        return self._radius
    
    @radius.setter
    def radius(self, value):
        if value > 0:
            self._radius = value
        else:
            raise ValueError("Радиус должен быть положительным")
    
    @property
    def area(self):
        return 3.14159 * self._radius ** 2
​
circle = Circle(5)
print(circle.radius)  # Вывод: 5
print(circle.area)    # Вывод: 78.53975
circle.radius = 10
print(circle.area)    # Вывод: 314.159

Где применяется инкапсуляция?
Инкапсуляция используется повсеместно:

Банковские системы: Защита баланса счёта от прямого изменения
Пользовательские данные: Хранение паролей и личной информации
API и библиотеки: Скрытие внутренней реализации от пользователей
Игровые движки: Управление состоянием игровых объектов

Преимущества инкапсуляции:
Безопасность данных: Контроль над тем, как данные изменяются
Гибкость: Возможность изменить реализацию без изменения интерфейса
Модульность: Каждый класс отвечает за свои данные
Удобство отладки: Все изменения данных проходят через определённые методы

